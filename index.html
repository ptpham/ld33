<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <title>ld33</title>
    <style>
      * { box-sizing: border-box; }
      html, body {
        margin: 0px;
        width: 100%;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
      body { position: relative } 
      overhead-bar {
        display: flex; position: absolute; padding: 20px; top: 0px;
        width: 100%; height: 80px;
      }
      health-bar {
        position: absolute; border-radius: 10px; overflow: hidden;
        border: 2px solid white; height: 20px; width: calc(100% - 40px);
      }
      health-filled {
        display: block;
        height: 100%; width: 100%; opacity: 0.3;
        background: green;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <overhead-bar>
      <health-bar>
        <health-filled id="healthIndicator"></health-filled>
      </health-bar>
    </overhead-bar>
  </body>
  <script id="food-vs" type="notjs">
    uniform mat4 u_worldViewProjection;
    uniform vec3 u_lightWorldPos;
    uniform mat4 u_world;
    uniform mat4 u_viewInverse;
    uniform mat4 u_worldInverseTranspose;
    uniform vec3 u_center;

    attribute vec4 a_position;
    attribute vec3 a_normal;
    attribute vec2 a_texcoord;

    varying vec4 v_position;
    varying vec2 v_texCoord;
    varying vec3 v_normal;
    varying vec3 v_surfaceToLight;
    varying vec3 v_surfaceToView;

    void main() {
      v_position = (u_worldViewProjection * a_position);
      vec4 diff = v_position - u_worldViewProjection*vec4(u_center, 1);
      v_texCoord = diff.xy * 0.3 + 0.5;
      v_texCoord[1] *= -1.;
      v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;
      v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;
      v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;
      gl_Position = v_position;
    }
  </script>
  <script id="food-fs" type="notjs">
    precision mediump float;

    varying vec4 v_position;
    varying vec2 v_texCoord;
    varying vec3 v_normal;
    varying vec3 v_surfaceToLight;
    varying vec3 v_surfaceToView;

    uniform vec4 u_lightColor;
    uniform vec4 u_diffuseMult;
    uniform sampler2D u_diffuse;
    uniform vec4 u_specular;
    uniform vec4 u_emissive;
    uniform float u_shininess;
    uniform float u_specularFactor;
    uniform float u_time;

    vec4 lit(float l ,float h, float m) {
      return vec4(1.0,
                  max(l, 0.2),
                  (l > 0.0) ? pow(max(0.0, h), m) : 0.0,
                  1.0);
    }

    void main() {
      vec2 new_texCoord = v_texCoord;
      new_texCoord[1] = v_texCoord[1] - (u_time / 100.0);
      vec4 sample = texture2D(u_diffuse, new_texCoord);
      vec4 diffuseColor = sample * u_diffuseMult;
      vec3 a_normal = normalize(v_normal);
      vec3 surfaceToLight = normalize(v_surfaceToLight);
      vec3 surfaceToView = normalize(v_surfaceToView);
      vec3 halfVector = normalize(surfaceToLight + surfaceToView);
      vec4 litR = lit(dot(a_normal, surfaceToLight),
                        dot(a_normal, halfVector), u_shininess);
      vec4 outColor = vec4((
      u_lightColor * (diffuseColor * litR.y +
                    u_specular * litR.z * u_specularFactor)).rgb,
          diffuseColor.a);  
      gl_FragColor = outColor + (1.0 - sample[0])*u_emissive;
    }
  </script>
  <script id="tower-vs" type="notjs">
    uniform mat4 u_worldViewProjection;
    uniform vec3 u_lightWorldPos;
    uniform mat4 u_world;
    uniform mat4 u_viewInverse;
    uniform mat4 u_worldInverseTranspose;

    attribute vec4 a_position;
    attribute vec3 a_normal;
    attribute vec2 a_texcoord;

    varying vec4 v_position;
    varying vec2 v_texCoord;
    varying vec3 v_normal;
    varying vec3 v_surfaceToLight;
    varying vec3 v_surfaceToView;

    void main() {
      v_texCoord = a_texcoord;
      v_position = (u_worldViewProjection * a_position);
      v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;
      v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;
      v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;
      gl_Position = v_position;
    }
  </script>
  <script id="worm-vs" type="notjs">
    uniform mat4 u_worldViewProjection;
    uniform vec3 u_lightWorldPos;
    uniform mat4 u_world;
    uniform mat4 u_viewInverse;
    uniform mat4 u_worldInverseTranspose;
    uniform float u_wormLength;
    uniform float u_wormOffset;

    attribute vec4 a_position;
    attribute vec3 a_normal;
    attribute vec2 a_texcoord;
    attribute vec3 a_spine;

    varying vec4 v_position;
    varying vec2 v_texCoord;
    varying vec3 v_normal;
    varying vec3 v_surfaceToLight;
    varying vec3 v_surfaceToView;

    void main() {
      float theta = a_spine[2];
      float radius = a_spine[0];
      float height = a_spine[1];
      vec4 pos = a_position;
      pos[1] = a_position[0];
      pos[0] = 0.0;
      float ctr = cos(theta + 1.5708);
      float str = sin(theta + 1.5708);
      float ct = cos(theta);
      float st = sin(theta);
      float scale = 1.0;
      float threshold = 0.2;
      float candidate = theta - u_wormOffset;
      float candidate2 = u_wormLength - theta;
      if (candidate >= threshold) candidate = candidate2;

      if (candidate < threshold) scale = sin(1.5708*(candidate)/threshold);
      vec4 normal = vec4(pos.xyz, 0.0);
      mat4 rot = mat4(vec4(ctr, 0, str, 0), vec4(0, scale, 0, 0), vec4(-scale*str, 0, scale*ctr, 0), vec4(0, 0, 0, 1));
      mat4 push_out = mat4(vec4(1, 0, 0, 0), vec4(0, 1, 0, 0), vec4(0, 0, 1, 0), vec4(radius*ct, height, radius*st, 1));
      pos = push_out*rot*pos;
      normal = normalize(rot*normal);

      float coord = (theta - u_wormOffset) / 1.5708;
      v_texCoord = vec2(coord - floor(coord), a_texcoord[0]);
      v_position = (u_worldViewProjection * pos);
      v_normal = (u_worldInverseTranspose * normal).xyz;
      v_surfaceToLight = u_lightWorldPos - (u_world * pos).xyz;
      v_surfaceToView = (u_viewInverse[3] - (u_world * pos)).xyz;
      gl_Position = v_position;
    }
  </script>
  <script id="tower-fs" type="notjs">
    precision mediump float;

    varying vec4 v_position;
    varying vec2 v_texCoord;
    varying vec3 v_normal;
    varying vec3 v_surfaceToLight;
    varying vec3 v_surfaceToView;

    uniform vec4 u_lightColor;
    uniform vec4 u_diffuseMult;
    uniform sampler2D u_diffuse;
    uniform vec4 u_specular;
    uniform vec4 u_emissive;
    uniform float u_shininess;
    uniform float u_specularFactor;
    uniform float u_time;

    vec4 lit(float l ,float h, float m) {
      return vec4(1.0,
                  max(l, 0.2),
                  (l > 0.0) ? pow(max(0.0, h), m) : 0.0,
                  1.0);
    }

    void main() {
      vec2 new_texCoord = v_texCoord;
      new_texCoord[1] = v_texCoord[1] - (u_time / 100.0);
      vec4 diffuseColor = texture2D(u_diffuse, new_texCoord) * u_diffuseMult;
      vec3 a_normal = normalize(v_normal);
      vec3 surfaceToLight = normalize(v_surfaceToLight);
      vec3 surfaceToView = normalize(v_surfaceToView);
      vec3 halfVector = normalize(surfaceToLight + surfaceToView);
      vec4 litR = lit(dot(a_normal, surfaceToLight),
                        dot(a_normal, halfVector), u_shininess);
      vec4 outColor = vec4((
      u_lightColor * (diffuseColor * litR.y +
                    u_specular * litR.z * u_specularFactor)).rgb,
          diffuseColor.a);
      gl_FragColor = outColor + u_emissive;
    }
  </script>
  <script>
    var lastMouse = [0, 0];
    document.addEventListener('mousemove', function(e) {
      lastMouse = [e.clientX, e.clientY];
    });
    
    var keysDown = { };
    document.addEventListener('keydown', function(e) {
      keysDown[e.keyCode] = true;
    });

    document.addEventListener('keyup', function(e) {
      delete keysDown[e.keyCode];
    });
  </script>
  <script src="lodash.min.js"></script>
  <script src="twgl-full.js"></script>
  <script src="chroma.min.js"></script>
  <script src="src/render.js"></script>


</html>



